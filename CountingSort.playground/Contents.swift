import UIKit

/*
 Внешний цикл for i in 0..<maxValue + 1 имеет длину maxValue + 1, а вложенный цикл for _ in 0..<container[i] выполняется количество раз, равное значению в container[i]. В итоге длина всех вложенных циклов в сумме равна n, потому что мы не добавляем элементы в sortList, которые не присутствуют в исходном списке. Это значит, что этот блок тоже будет O(n).

 Итак, основной вклад в сложность алгоритма даёт операция подсчета и заполнение массива, что ведёт к общей сложности алгоритма:

 - *Сложность по времени*: O(n + k), где
   - n — количество элементов в входном массиве,
   - k — значение maxValue (максимальное значение в массиве).

 - *Сложность по пространству*: O(k), для хранения контейнера (если считать место, занимаемое входным массивом, например, n, то в общем случае будет O(n + k)).

 В итоге, алгоритм сортировки подсчетом эффективен для массивов с небольшим диапазоном значений (k относительно n), но может быть неэффективен, если k значительно больше n.
 */


func countingSort(list: [Int]) -> [Int]? {
    var sortList = list
    let maxValue = list.max() ?? 0
    var container = Array(repeating: 0, count: maxValue + 1)
    
    if list.contains(where: {
        $0 < 0
    }) {
        return nil
    }
    
    list.forEach {
        container[$0] += 1
    }
    
    var elem = 0
    
    for i in 0..<maxValue + 1 {
        for _ in 0..<container[i] {
            sortList[elem] = i
            elem += 1
        }
    }
    
    return sortList
}

countingSort(list: [4,3,2,5])
